# -*- coding: utf-8 -*-
"""Main File.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CkQsNvZU8YGTeOc_nq2DhKBfEzshCeMe

# ELL710 Coding Theory
### *Semester 1 : 2023-24*

## Assignment 1
### Submission Date: 10/09/2023

### Animesh Jhawar: 2020EE10468

# Part 1
### The case of uncoded scheme

First the basic libraries are imported.
"""

import numpy as np
import pandas as pd
import cv2
from google.colab.patches import cv2_imshow
from skimage import io
from PIL import Image
import matplotlib.pylab as plt

"""### 1
Image to bits function is defined here.
"""

def image_to_bits(image):
  grayscale_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
  resized_image = cv2.resize(grayscale_image, (128, 128))
  print(grayscale_image)
  bits = resized_image.reshape(-1).astype(np.uint8)
  return bits

"""### 2
Stores bits in capacitors with transition probability p.
"""

def store_bits_in_capacitors(bits, p):
  capacitors = np.zeros((len(bits)), dtype=np.float32)
  for i in range(len(bits)):
    if np.random.rand() < p:
      capacitors[i] = 1  #generate a array of zeroes and one in between and then XOR
    else:
      capacitors[i] = 0
  return capacitors

"""### 3
Recovers bits from capacitors and reconstructs an image from bits.

"""

def recover_bits_from_capacitors(capacitors):
  bits_r = np.zeros((len(capacitors)), dtype=np.uint8)
  for i in range(len(capacitors)):
    if capacitors[i] > 0.5:
      bits_r[i] = 1
  return bits_r

def xor_strings(s1, s2):
    s3 = ""
    for i in range(len(s1)):
        if (int(s1[i]) ^ int(s2[i])) == 0:
            s3 += "0"
        else:
            s3 += "1"
    return s3

def add_noise(image, p):
  noise = np.random.binomial(1, p, len(image))
  noisy_image = xor_strings(noise, image)
  return noisy_image

def binary_to_decimal(binary):
  decimal = 0
  power = 0
  for i in range(len(binary) - 1, -1, -1):
    decimal += int(binary[i]) * pow(2, power)
    power += 1
  return decimal

def reconstruct_image(bits_recovered, width, height):
  image = np.zeros((width, height, 3), dtype=np.uint8)
  temp = 0
  for i in range(width):
    for j in range(height):
      for k in range(3):
        s = bits_recovered[temp: temp + 8]
        temp += 8
        image[i][j][k] = binary_to_decimal(s)
  return image

"""### Main Function
Different values of p are considered.
"""

def main():
  image = io.imread('https://images.unsplash.com/photo-1552519507-da3b142c6e3d?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1470&q=80')
  bits = image_to_bits(image)

  p_values = [1e-4, 1e-3, 1e-2, 0.1]
  noisy_images = []
  for p in p_values:
    noisy_images.append(add_noise(bits, p))

  # Reconstruct the images.
  images_reconstructed = []
  for noisy_image in noisy_images:
    images_reconstructed.append(reconstruct_image(noisy_image, image.shape[1], image.shape[0]))

  # Display the images.
  plt.subplot(2, 2, 1)
  plt.title("Orignal Image")
  plt.imshow(image)
  plt.show()
  print("Reconstructed Images")
  for i, image_reconstructed in enumerate(images_reconstructed):
    plt.subplot(2, 2, i + 1)
    plt.imshow(image_reconstructed)
    plt.title("p = " + str(p_values[i]))
  plt.subplots_adjust(bottom=0.1, hspace=0.5)
  plt.show()

"""### Output
Calling the main funciton
"""

if __name__ == "__main__":
  main()